<!DOCTYPE html>
<html lang="pt-BR" xml:lang="pt-BR">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Capítulo 3 Estimação Baseada no Plano Amostral | Análise de Dados Amostrais com R</title>
  <meta name="description" content="Análise de dados de pesquisas amostrais." />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="Capítulo 3 Estimação Baseada no Plano Amostral | Análise de Dados Amostrais com R" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="/Figuras/capa.png" />
  <meta property="og:description" content="Análise de dados de pesquisas amostrais." />
  <meta name="github-repo" content="PedroNSilva/ADACOR" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Capítulo 3 Estimação Baseada no Plano Amostral | Análise de Dados Amostrais com R" />
  
  <meta name="twitter:description" content="Análise de dados de pesquisas amostrais." />
  <meta name="twitter:image" content="/Figuras/capa.png" />




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="refinf.html"/>
<link rel="next" href="epa.html"/>
<script src="libs/header-attrs-2.11/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Bem-vindo</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#agradecimentos"><i class="fa fa-check"></i>Agradecimentos</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="lista-de-figuras.html"><a href="lista-de-figuras.html"><i class="fa fa-check"></i>Lista de Figuras</a></li>
<li class="chapter" data-level="" data-path="lista-de-siglas.html"><a href="lista-de-siglas.html"><i class="fa fa-check"></i>Lista de Siglas</a></li>
<li class="chapter" data-level="" data-path="lista-de-tabelas.html"><a href="lista-de-tabelas.html"><i class="fa fa-check"></i>Lista de Tabelas</a></li>
<li class="chapter" data-level="1" data-path="introduc.html"><a href="introduc.html"><i class="fa fa-check"></i><b>1</b> Introdução</a>
<ul>
<li class="chapter" data-level="1.1" data-path="introduc.html"><a href="introduc.html#motivação"><i class="fa fa-check"></i><b>1.1</b> Motivação</a></li>
<li class="chapter" data-level="1.2" data-path="introduc.html"><a href="introduc.html#objetivos-do-livro"><i class="fa fa-check"></i><b>1.2</b> Objetivos do livro</a></li>
<li class="chapter" data-level="1.3" data-path="introduc.html"><a href="introduc.html#estrutura-do-livro"><i class="fa fa-check"></i><b>1.3</b> Estrutura do livro</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="refinf.html"><a href="refinf.html"><i class="fa fa-check"></i><b>2</b> Referencial para Inferência</a>
<ul>
<li class="chapter" data-level="2.1" data-path="refinf.html"><a href="refinf.html#modelagem---primeiras-ideias"><i class="fa fa-check"></i><b>2.1</b> Modelagem - Primeiras ideias</a></li>
<li class="chapter" data-level="2.2" data-path="refinf.html"><a href="refinf.html#classic"><i class="fa fa-check"></i><b>2.2</b> Abordagem 1 - Modelagem Clássica</a></li>
<li class="chapter" data-level="2.3" data-path="refinf.html"><a href="refinf.html#abordagem-2---amostragem-probabilística"><i class="fa fa-check"></i><b>2.3</b> Abordagem 2 - Amostragem Probabilística</a></li>
<li class="chapter" data-level="2.4" data-path="refinf.html"><a href="refinf.html#discussão-das-abordagens-1-e-2"><i class="fa fa-check"></i><b>2.4</b> Discussão das abordagens 1 e 2</a></li>
<li class="chapter" data-level="2.5" data-path="refinf.html"><a href="refinf.html#modelsuperpop"><i class="fa fa-check"></i><b>2.5</b> Abordagem 3 - Modelagem de Superpopulação</a></li>
<li class="chapter" data-level="2.6" data-path="refinf.html"><a href="refinf.html#fontes-de-variação"><i class="fa fa-check"></i><b>2.6</b> Fontes de variação</a></li>
<li class="chapter" data-level="2.7" data-path="refinf.html"><a href="refinf.html#modelos-de-superpopulação"><i class="fa fa-check"></i><b>2.7</b> Modelos de Superpopulação</a></li>
<li class="chapter" data-level="2.8" data-path="refinf.html"><a href="refinf.html#planamo"><i class="fa fa-check"></i><b>2.8</b> Plano amostral</a></li>
<li class="chapter" data-level="2.9" data-path="refinf.html"><a href="refinf.html#inform"><i class="fa fa-check"></i><b>2.9</b> Planos amostrais informativos e ignoráveis</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="capplanamo.html"><a href="capplanamo.html"><i class="fa fa-check"></i><b>3</b> Estimação Baseada no Plano Amostral</a>
<ul>
<li class="chapter" data-level="3.1" data-path="capplanamo.html"><a href="capplanamo.html#estimatotais"><i class="fa fa-check"></i><b>3.1</b> Estimação de totais</a></li>
<li class="chapter" data-level="3.2" data-path="capplanamo.html"><a href="capplanamo.html#estimação-de-variâncias---motivação"><i class="fa fa-check"></i><b>3.2</b> Estimação de variâncias - motivação</a></li>
<li class="chapter" data-level="3.3" data-path="capplanamo.html"><a href="capplanamo.html#taylor"><i class="fa fa-check"></i><b>3.3</b> Linearização de Taylor (ou Delta) para estimar variâncias</a></li>
<li class="chapter" data-level="3.4" data-path="capplanamo.html"><a href="capplanamo.html#equações-de-estimação"><i class="fa fa-check"></i><b>3.4</b> Equações de estimação</a></li>
<li class="chapter" data-level="3.5" data-path="capplanamo.html"><a href="capplanamo.html#método-do-conglomerado-primário"><i class="fa fa-check"></i><b>3.5</b> Método do Conglomerado Primário</a></li>
<li class="chapter" data-level="3.6" data-path="capplanamo.html"><a href="capplanamo.html#métodos-de-replicação"><i class="fa fa-check"></i><b>3.6</b> Métodos de replicação</a></li>
<li class="chapter" data-level="3.7" data-path="capplanamo.html"><a href="capplanamo.html#laboratório-de-r"><i class="fa fa-check"></i><b>3.7</b> Laboratório de R</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="epa.html"><a href="epa.html"><i class="fa fa-check"></i><b>4</b> Efeitos do Plano Amostral</a>
<ul>
<li class="chapter" data-level="4.1" data-path="epa.html"><a href="epa.html#secC4N1"><i class="fa fa-check"></i><b>4.1</b> Introdução</a></li>
<li class="chapter" data-level="4.2" data-path="epa.html"><a href="epa.html#secC4N2"><i class="fa fa-check"></i><b>4.2</b> Efeito do Plano Amostral - EPA de Kish</a></li>
<li class="chapter" data-level="4.3" data-path="epa.html"><a href="epa.html#secC4N3"><i class="fa fa-check"></i><b>4.3</b> Efeito do Plano Amostral Ampliado</a></li>
<li class="chapter" data-level="4.4" data-path="epa.html"><a href="epa.html#secC4N4"><i class="fa fa-check"></i><b>4.4</b> Efeitos sobre Intervalos de Confiança e Testes de Hipóteses Uniparamétricos</a></li>
<li class="chapter" data-level="4.5" data-path="epa.html"><a href="epa.html#secC4N5"><i class="fa fa-check"></i><b>4.5</b> Efeitos Multivariados de Plano Amostral</a></li>
<li class="chapter" data-level="4.6" data-path="epa.html"><a href="epa.html#secC4N6"><i class="fa fa-check"></i><b>4.6</b> Laboratório de R</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="ajmodpar.html"><a href="ajmodpar.html"><i class="fa fa-check"></i><b>5</b> Ajuste de Modelos Paramétricos</a>
<ul>
<li class="chapter" data-level="5.1" data-path="ajmodpar.html"><a href="ajmodpar.html#modpar1"><i class="fa fa-check"></i><b>5.1</b> Introdução</a></li>
<li class="chapter" data-level="5.2" data-path="ajmodpar.html"><a href="ajmodpar.html#método-de-máxima-verossimilhança-mv"><i class="fa fa-check"></i><b>5.2</b> Método de Máxima Verossimilhança (MV)</a></li>
<li class="chapter" data-level="5.3" data-path="ajmodpar.html"><a href="ajmodpar.html#ponderação-de-dados-amostrais"><i class="fa fa-check"></i><b>5.3</b> Ponderação de Dados Amostrais</a></li>
<li class="chapter" data-level="5.4" data-path="ajmodpar.html"><a href="ajmodpar.html#modpar3"><i class="fa fa-check"></i><b>5.4</b> Método de Máxima Pseudo-Verossimilhança</a></li>
<li class="chapter" data-level="5.5" data-path="ajmodpar.html"><a href="ajmodpar.html#robustez-do-procedimento-mpv"><i class="fa fa-check"></i><b>5.5</b> Robustez do Procedimento MPV</a></li>
<li class="chapter" data-level="5.6" data-path="ajmodpar.html"><a href="ajmodpar.html#desvantagens-da-inferência-de-aleatorização"><i class="fa fa-check"></i><b>5.6</b> Desvantagens da Inferência de Aleatorização</a></li>
<li class="chapter" data-level="5.7" data-path="ajmodpar.html"><a href="ajmodpar.html#laboratório-de-r-1"><i class="fa fa-check"></i><b>5.7</b> Laboratório de R</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="referências.html"><a href="referências.html"><i class="fa fa-check"></i>Referências</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Análise de Dados Amostrais com R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="capplanamo" class="section level1" number="3">
<h1><span class="header-section-number">Capítulo 3</span> Estimação Baseada no Plano Amostral</h1>
<div id="estimatotais" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Estimação de totais</h2>
<div style="text-align: justify">
<p>Devido a sua importância para os desenvolvimentos teóricos em vários dos capítulos subsequentes, alguns resultados básicos relativos à estimação de totais da população finita numa abordagem baseada no plano amostral são relembrados nesta seção. A referência básica usada foi a Seção 2.8 de <span class="citation">Särndal et al. (1992)</span>. O leitor pode também consultar o Capítulo 3 de <span class="citation">Silva et al. (2020)</span>.</p>
<p>Consideremos o problema de estimar o vetor <span class="math inline">\(\mathbf{Y} = \sum_{i \in U} \mathbf{y}_i\)</span> de totais das <span class="math inline">\(Q\)</span> variáveis da pesquisa na população, a partir de uma amostra observada <span class="math inline">\(s\)</span>. Naturalmente, qualquer estimador viável do total <span class="math inline">\(\mathbf{Y}\)</span> só pode depender dos valores das variáveis de pesquisa observados na amostra, contidos em <span class="math inline">\(\mathbf{y}_{i_{1}}, \ldots , \mathbf{y}_{i_{n}}\)</span>, mas não dos valores dessas variáveis para os elementos não pesquisados (<span class="math inline">\(i \in U-s\)</span>).</p>
<p>Um estimador usual baseado no plano amostral para o total <span class="math inline">\(\mathbf{Y}\)</span> é o estimador de Horvitz-Thompson (ver Capítulo <a href="refinf.html#refinf">2</a> deste livro e Seção 3.7 de <span class="citation">Silva et al. (2020)</span>), dado por:</p>
<p><span class="math display" id="eq:estpa1">\[\begin{equation}
\widehat{\mathbf{Y}}_{HT} = \sum_{i \in s} \mathbf{y}_i / \pi_{i} = \sum_{i \in s} d_i \mathbf{y}_i \,\,  \tag{3.1}
\end{equation}\]</span>
onde <span class="math inline">\(d_i = 1/\pi_i\)</span> é o <em>peso básico</em> da unidade <span class="math inline">\(i\)</span>.</p>
<p>Na abordagem baseada no planejamento amostral, as propriedades de uma estatística ou estimador são avaliadas com respeito a sua <em>distribuição de aleatorização</em>. Denotemos por <span class="math inline">\(E_p(.)\)</span> e <span class="math inline">\(V_p(.)\)</span> os operadores de esperança e variância referentes à distribuição de probabilidades induzida pelo planejamento amostral <span class="math inline">\(p(s)\)</span>, que chamaremos daqui por diante de <em>esperança de aleatorização</em> e <em>variância de aleatorização</em>.</p>
<p>O estimador <span class="math inline">\(\mathbf{\widehat{Y}}_{HT}\)</span> é não viciado para o total <span class="math inline">\(\mathbf{Y}\)</span> com respeito à distribuição de aleatorização, isto é:</p>
<p><span class="math display">\[
E_p \left( \mathbf{\widehat{Y}}_{HT} \right) = \mathbf{Y} 
\]</span></p>
<p>Além disto, sua variância de aleatorização é dada por</p>
<p><span class="math display" id="eq:estpa2">\[\begin{equation}
V_p \left( \mathbf{\widehat{Y}}_{HT} \right) = \sum_{i \in U} \sum_{j \in U} \left( \frac{d_i d_j}{d_{ij}} - 1 \right) \mathbf{y}_i {\mathbf{y}^\prime_j}  \,\,\,  \tag{3.2}
\end{equation}\]</span></p>
<p>Um estimador não viciado para a variância de aleatorização de <span class="math inline">\(\mathbf{ \widehat{Y}}_{HT}\)</span> é dado por:</p>
<p><span class="math display" id="eq:estpa3">\[\begin{equation}
\widehat V_p \left( \mathbf{\widehat{Y}}_{HT} \right) =\sum_{i \in s} \sum_{j \in s} \left( {d_i d_j} - d_{ij} \right) \mathbf{y}_i {\mathbf{y}^\prime_j}  \,\,\, \tag{3.3}
\end{equation}\]</span></p>
<p>O estimador de variância em <a href="capplanamo.html#eq:estpa3">(3.3)</a> é um estimador não viciado da variância de aleatorização de <span class="math inline">\(\mathbf{\widehat{Y}}_{HT}\)</span>, isto é</p>
<p><span class="math display" id="eq:estpa4">\[\begin{equation}
E_p \left[ \widehat V_p \left( \mathbf{\widehat{Y}}_{HT} \right) \right] = V_p \left( \mathbf{\widehat{Y}}_{HT} \right) \,\,\, \tag{3.4}
\end{equation}\]</span></p>
<p>desde que <span class="math inline">\(\pi_{ij} &gt; 0 \quad \forall\,\, i \neq j \in U\)</span>, como vamos supor neste livro.</p>

<div class="example">
<span id="exm:exe31" class="example"><strong>Exemplo 3.1  </strong></span>Amostragem Aleatória Simples Sem Reposição - AAS
</div>
<p>Quando o plano amostral empregado num levantamento é amostragem aleatória simples sem reposição - AAS, as expressões apresentadas para o estimador de total, sua variância e estimadores desta variância simplificam bastante, porque as probabilidades de inclusão e os pesos básicos das unidades ficam iguais a</p>
<p><span class="math display" id="eq:estpa5">\[\begin{equation}
\pi_i = \frac{n}{N}\,\text{ e }\, d_i = \frac{N}{n} \, \,\, \forall \,\,i \in U  \,\, \tag{3.5}
\end{equation}\]</span></p>
<p>e</p>
<p><span class="math display" id="eq:estpa6">\[\begin{equation}
\pi_{ij} = \frac{n(n-1)}{N(N-1)} \,\, \,\,\,\text{e} \,\,  d_{ij} = \frac{N(N-1)}{n(n-1)} \,\,\, \forall \, i \neq j \in U \,\, \tag{3.6} 
\end{equation}\]</span></p>
<p>Essas probabilidades de inclusão e pesos básicos levam às seguintes expressões simplificadas para o caso AAS:</p>
<p><span class="math display" id="eq:estpa7">\[\begin{equation}
\widehat{\mathbf{Y}}_{AAS} = \frac{N}{n} \sum_{i \in s} \mathbf{y}_i = N \, \overline{\mathbf{y}}  \,\, \tag{3.7}
\end{equation}\]</span></p>
<p>onde</p>
<p><span class="math display" id="eq:estpa8">\[\begin{equation}
\overline{\mathbf{y}} = \frac{1}{n} \sum_{i \in s} \mathbf{y}_i  \,\, \tag{3.8}
\end{equation}\]</span></p>
<p><span class="math display" id="eq:estpa9">\[\begin{equation}
V_{AAS} \left( \mathbf{\widehat{Y}}_{AAS} \right) = N^{2} \left( \frac{1}{n} - \frac{1}{N} \right) \mathbf{S}_y \,\, \tag{3.9}
\end{equation}\]</span></p>
<p>onde</p>
<p><span class="math display" id="eq:estpa10">\[\begin{equation}
\mathbf{S}_y = \frac{1}{N-1} \sum_{i \in U} \left( \mathbf{y}_i - \overline{ \mathbf{Y}} \right) \left( \mathbf{y}_i - \overline{\mathbf{Y}} \right) ^{^{\prime }}   \tag{3.10}
\end{equation}\]</span></p>
<p><span class="math display" id="eq:estpa11">\[\begin{equation}
\overline{\mathbf{Y}} = \frac{1}{N} \sum_{i \in U} \mathbf{y}_i = \frac{1}{N} \mathbf{Y} \,\,\, \tag{3.11}
\end{equation}\]</span></p>
<p>Sob AAS, o estimador da variância do estimador de total simplifica para:</p>
<p><span class="math display" id="eq:estpa12">\[\begin{equation}
\widehat{V}_{AAS} \left( \mathbf{\widehat{Y}}_{AAS} \right) = N^{2} \left( \frac{1}{n} - \frac{1}{N} \right) \mathbf{\widehat S}_y \,\, \tag{3.12}
\end{equation}\]</span></p>
<p>onde</p>
<p><span class="math display" id="eq:estpa13">\[\begin{equation}
\widehat{\mathbf{S}}_y = \frac{1}{n-1} \sum_{i \in s} \left( \mathbf{y}_i - \overline{\mathbf{y}} \right) \left( \mathbf{y}_i - \overline{\mathbf{y}} \right) ^{^{\prime }} \,\,\, \tag{3.13} 
\end{equation}\]</span></p>
<p>Vários outros estimadores de totais estão disponíveis na literatura de amostragem, porém os que são comumente usados na prática são estimadores ponderados (lineares) da forma</p>
<p><span class="math display" id="eq:estpa14">\[\begin{equation}
\mathbf{\widehat{Y}}_w = \sum\limits_{i \in s} w_i \mathbf{y}_i  \,\,\, \tag{3.14}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(w_i\)</span> é um peso associado à unidade <span class="math inline">\(i\)</span> da amostra (<span class="math inline">\(i \in s\)</span>).</p>
<p>O estimador de Horvitz-Thompson é um caso particular de <span class="math inline">\(\mathbf{\widehat{Y}}_w\)</span> em <a href="capplanamo.html#eq:estpa14">(3.14)</a> quando os pesos <span class="math inline">\(w_i\)</span> são da forma</p>
<p><span class="math display">\[
w_i^{HT} = d_i = 1 / \pi_i \quad \forall \ i \in s. 
\]</span></p>
<p>Outros dois estimadores de totais comumente usados pelos praticantes de amostragem são o <em>estimador de razão simples</em> <span class="math inline">\(\mathbf{\widehat{Y}}_R\)</span> e o <em>estimador de regressão simples</em> <span class="math inline">\(\mathbf{\widehat{Y}}_{REG}\)</span>, dados respectivamente por</p>
<p><span class="math display" id="eq:estpa15">\[\begin{equation}
\mathbf{\widehat{Y}}_R = \sum_{i \in s} {w_i^{R} \ } \mathbf{y}_i \,\,\,  \tag{3.15}
\end{equation}\]</span></p>
<p>com</p>
<p><span class="math display" id="eq:estpa16">\[\begin{equation}
w_i^{R} = d_i \times \frac{\sum_{i \in U} x_i } {\sum_{i \in s} {d_i \ } x_i} = d_i \times \frac{X}{\widehat{X}_{HT}}  \,\,\,  \tag{3.16}
\end{equation}\]</span></p>
<p>e</p>
<p><span class="math display" id="eq:estpa17">\[\begin{equation}
\mathbf{\widehat{Y}}_{REG} = \sum_{i \in s} {w_i^{REG} \ } \mathbf{y}_i \,\,\,  \tag{3.17}
\end{equation}\]</span></p>
<p>onde</p>
<p><span class="math display" id="eq:estpa18">\[\begin{equation}
w_i^{REG} = d_i \times g_i \,\,\, \tag{3.18}
\end{equation}\]</span></p>
<p>sendo</p>
<p><span class="math display">\[
g_{i} = 1 + x_{i \mbox{ }} (X - \widehat{X}_{HT}) / \sum_{i \in s} d_i x_i^2
\]</span></p>
<p>O fator multiplicativo de ajuste de regressão <span class="math inline">\(g_i\)</span> depende de conhecermos o total populacional <span class="math inline">\(\sum_{i \in U} x_i = X\)</span> de uma variável auxiliar <span class="math inline">\(x\)</span>, e do estimador tipo Horvitz-Thompson para esse total dado por <span class="math inline">\(\widehat{X}_{HT} = \sum_{i \in s} d_i \, x_i\)</span>.</p>
<p>O estimador de regressão descrito em <a href="capplanamo.html#eq:estpa17">(3.17)</a> é um caso particular do <em>estimador de regressão generalizado</em>, obtido quando se consideram vetores de variáveis auxiliares em vez de uma única variável auxiliar <span class="math inline">\(x\)</span> como aqui. Para uma discussão detalhada do <em>estimador de regressão generalizado</em> ver o Capítulo 3 de <span class="citation">Silva (1996)</span>, ou o excelente livro de <span class="citation">Särndal et al. (1992)</span>. Por sua vez, o <em>estimador de regressão generalizado</em> é caso particular da família mais ampla dos <em>estimadores de calibração</em>, definidos por <span class="citation">Deville e Särndal (1992)</span>. Mais informações sobre esta família de estimadores no Capítulo 13 de <span class="citation">Silva et al. (2020)</span>.</p>
<p>Para completar a descrição dos procedimentos de inferência para médias e totais baseados em estimadores ponderados do tipo razão ou regressão, é necessário identificar estimadores para as variâncias de aleatorização correspondentes. Entretanto, os estimadores de razão e regressão são viciados sob a distribuição de aleatorização para pequenas amostras. Em ambos os casos, o vício é desprezível para amostras grandes, e estão disponíveis expressões assintóticas para as respectivas variâncias de aleatorização.</p>
<p>Partindo destas expressões foram então construídos estimadores amostrais das variâncias dos estimadores de razão e regressão, que podem ser encontrados na excelente revisão sobre o tema contida em <span class="citation">Särndal et al. (1992)</span>, Seção 6.6 e Capítulo 7. Apesar de sua importância para os praticantes de amostragem, a discussão detalhada desse problema não está incluída neste livro.</p>
<p>O problema da estimação das variâncias de aleatorização para estimadores como os de razão e regressão nos remete a uma questão central da teoria da amostragem. Trata-se dos métodos disponíveis para estimar variâncias de estimadores “complexos”. O caso dos estimadores de razão e regressão para totais e médias foi resolvido faz tempo, e não há muito o que discutir aqui. Entretanto, a variedade de métodos empregados para estimação de variâncias merece uma discussão em separado, pois as técnicas de ajuste consideradas neste livro para incorporar pesos e plano amostral na inferência partindo de dados de pesquisas amostrais complexas depende em grande medida da aplicação de tais técnicas.</p>
</div>
<div id="estimação-de-variâncias---motivação" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Estimação de variâncias - motivação</h2>
<div style="text-align: justify">
<p>Em Amostragem, como de resto na Estatística Clássica, a estimação de variâncias é um componente <em>essencial</em> da abordagem inferencial adotada: sem estimativas de variância, nenhuma indicação da precisão (e, portanto, da qualidade) das estimativas
de interesse está disponível. Nesse caso, uma tentação que assola muitos usuários incautos é esquecer que os resultados são baseados apenas em dados de uma amostra da população e, portanto, sujeitos a incerteza, que não pode ser quantificada sem medidas de precisão amostral.</p>
<p>Em geral, a obtenção de estimativas de variâncias (alternativamente, de desvios padrões ou mesmo de coeficientes de variação) é requerida para que intervalos de confiança possam ser calculados, e outras formas de inferência realizadas. Intervalos de confiança elaborados com estimativas amostrais são geralmente
baseados em aproximações assintóticas da distribuição amostral do estimador pela distribuição normal, usando resultados análogos ao TCL para populações finitas - ver <span class="citation">Wayne A. Fuller (2009)</span>, tais que intervalos da forma</p>
<p><span class="math display">\[
IC\left[ \widehat{\theta } ; 1-\alpha \right] =\left[ \,\, \widehat{\theta } \mp z_{\alpha /2}\sqrt{\widehat{V}_{p} \left( \widehat{\theta} \right) } \,\, \right] 
\]</span></p>
<p>têm probabilidade de cobertura aproximada <span class="math inline">\(1-\alpha\)</span>, com <span class="math inline">\(z_{\alpha /2}\)</span> sendo o quantil que deixa área de <span class="math inline">\(1-\alpha/2\)</span> à sua esquerda na distribuição Normal padrão.</p>
<p>Estimativas de variância podem ser úteis também para outras finalidades, tais como a detecção de problemas não antecipados, tais como observações suspeitas, celas raras em tabelas de contingência, etc.</p>
<p>A estimação de variâncias para os casos padrões de amostragem, isto é, quando os estimadores são lineares nas observações amostrais, não viciados e todas as probabilidades de inclusão conjuntas são não nulas, é tratada em todos os
livros de amostragem convencionais. Apesar disso, os pacotes estatísticos usuais, tais como SAS, SPSS, MINITAB e outros, por muito tempo não ofereciam rotinas prontas para estimar variâncias considerando o plano amostral, nem mesmo para estatísticas simples como estimadores de totais e médias.</p>
<p>Felizmente tal situação mudou, e agora já é possível contar com ferramentas no SAS (procedimentos <em>survey</em>), no SPSS (módulo <em>Complex Samples</em>) e no STATA (funções <em>svy</em>). Mas, a nosso ver, é no pacote <em>survey</em> do sistema R que estão disponíveis as melhores ferramentas para estimação de parâmetros a partir de dados de amostras complexas.</p>
<p>Para alguns planos amostrais utilizados na prática, as probabilidades de inclusão conjuntas podem ser nulas (caso de amostragem sistemática) ou difíceis de calcular (caso de alguns esquemas de seleção com probabilidades desiguais). Nesses casos, as expressões fornecidas na Seção <a href="capplanamo.html#estimatotais">3.1</a> para os estimadores das variâncias dos estimadores de totais não são mais adequadas.</p>
<p>Em muitos outros casos, como se vê no restante deste livro, os parâmetros de interesse são “não lineares” (diferentes de totais, médias e proporções, por exemplo). Casos comuns que consideremos mais adiante são a estimação de razões,
coeficientes de modelos de regressão etc. Nesses casos é comum que as estatísticas empregadas para estimar tais parâmetros também sejam “não lineares”.</p>
<p>Finalmente, alguns estimadores de variância podem, em alguns casos, produzir estimativas negativas da variância, que são inaceitáveis de um ponto de vista prático (tais como o estimador da expressão <a href="capplanamo.html#eq:estpa3">(3.3)</a> para alguns esquemas de seleção com probabilidades desiguais e determinadas configurações peculiares da
amostra).</p>
<p>Em todos esses casos, é requerido o emprego de técnicas especiais de estimação de variância. É de algumas dessas técnicas que tratam as seções seguintes deste capítulo. A seleção das técnicas discutidas aqui não é exaustiva, e um tratamento
mais completo e aprofundado da questão pode ser encontrado no livro de <span class="citation">Wolter (2007)</span>.
Discutimos inicialmente a técnica de <em>Linearização de Taylor</em>, em seguida uma abordagem comumente adotada para estimar variâncias para planos amostrais estratificados e conglomerados em vários estágios, com seleção de unidades primárias com probabilidades desiguais, denominada <em>Método do Conglomerado Primário</em> (do inglês <em>Ultimate Cluster</em>). Por último, tratamos brevemente de uma técnica baseada na ideia de pseudo replicações da amostra, denominada <em>Bootstrap</em>. A combinação dessas três idéias suporta os desenvolvimentos teóricos dos algoritmos empregados pelo pacote <em>survey</em> do sistema R para estimação de variâncias - ver <span class="citation">Lumley (2006)</span> e <span class="citation">Lumley (2010)</span>.</p>
</div>
<div id="taylor" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Linearização de Taylor (ou Delta) para estimar variâncias</h2>
<div style="text-align: justify">
<p>Um problema que ocorre frequentemente é o de estimar um vetor de parâmetros
<span class="math inline">\(\mathbf{\theta} = \left( \theta _{1},\ldots ,\theta_{K}\right)\)</span> de uma população finita <span class="math inline">\(U\)</span>, que pode ser escrito na forma:</p>
<p><span class="math display">\[
\mathbf{\theta} = \mathbf{g}(\mathbf{Y}) 
\]</span>
onde <span class="math inline">\(\mathbf{Y} = \sum_{i \in U} \mathbf{y}_i\)</span> é o vetor de totais de <span class="math inline">\(Q\)</span> variáveis de pesquisa.</p>
<p>Poderíamos usar como estimador para o vetor de parâmetros <span class="math inline">\(\theta\)</span> o estimador <span class="math inline">\(\mathbf{\widehat{\theta}}\)</span> dado por:</p>
<p><span class="math display">\[
\mathbf{\widehat{\theta}} = \mathbf{g} \left( \widehat{ \mathbf{Y}}_{HT} \right) = \mathbf{g} \left(\sum_{i \in s} \, d_i \, \mathbf{y}_{i} \right)  
\]</span>
No caso particular em que <span class="math inline">\(\mathbf{g}(\bullet)\)</span> é uma função linear dos totais das variáveis de pesquisa, isto é:</p>
<p><span class="math display">\[
\mathbf{\theta} = \mathbf{A Y}  
\]</span>
onde <span class="math inline">\(\mathbf{A}\)</span> é uma matriz de constantes de dimensão <span class="math inline">\(K \times Q\)</span>, o estimador
<span class="math inline">\(\mathbf{\widehat{\theta}}\)</span> de <span class="math inline">\(\mathbf{\theta}\)</span> neste caso seria</p>
<p><span class="math display">\[
\mathbf{\widehat{\theta}} = \mathbf{A \widehat{Y}}_{HT} \,
\]</span>
Nesse caso particular, é fácil estudar as propriedades do estimador <span class="math inline">\(\mathbf{\widehat{\theta}}\)</span>. Este estimador é não viciado e tem variância de aleatorização dada por:</p>
<p><span class="math display">\[
V_{p}\left( \mathbf{\widehat{\theta}} \right) = \mathbf{A} \left[ V_{p} \left( \mathbf{\widehat{Y}}_{HT} \right) \right] \mathbf{A}^{^{\prime }} \,\,
\]</span>
onde <span class="math inline">\(V_{p} \left( \mathbf{\widehat{Y}}_{HT}\right)\)</span> é dado em <a href="capplanamo.html#eq:estpa2">(3.2)</a>.</p>
<p>Quando <span class="math inline">\(\mathbf{g}(\bullet)\)</span> é uma função não linear, podemos usar a técnica de <em>Linearização de Taylor</em> (ou Método Delta) para obter aproximações assintóticas para a variância de <span class="math inline">\(\mathbf{ \widehat{\theta}} = \mathbf{g} \left( \widehat{\mathbf{Y}}_{HT}\right)\)</span>. Para maiores detalhes sobre esse método, ver por exemplo p. 172 de <span class="citation">Särndal et al. (1992)</span> ou p. 486 de <span class="citation">Bishop et al. (1975)</span>.</p>
<p>Vamos considerar a expansão de <span class="math inline">\(\mathbf{g} \left( \mathbf{\widehat{Y}}_{HT} \right)\)</span> em torno de <span class="math inline">\(\mathbf{Y}\)</span>, até o termo de primeira ordem, desprezando o resto, dada por:</p>
<p><span class="math display" id="eq:estpa19">\[\begin{equation}
\mathbf{\widehat{\theta} \doteq  \widehat{\theta}}_{L} = \mathbf{g(Y) + \Delta g(Y)} \left( \mathbf{\widehat{Y}}_{HT} - \mathbf{Y} \right) \,\,\, \tag{3.19}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\mathbf{\Delta g(Y)}\)</span> é a matriz Jacobiana <span class="math inline">\(K \times Q\)</span> cuja <span class="math inline">\(q\)</span>-ésima coluna é <span class="math inline">\(\mathbf{\partial g(Y)/}\partial Y_{q}\)</span>, para <span class="math inline">\(q=1,\ldots, Q\)</span>.</p>
<p>A ideia básica do método de linearização é aproximar a variância do estimador <span class="math inline">\(\mathbf{\widehat{\theta}}\)</span> pela variância do <em>estimador linearizado</em> <span class="math inline">\(\mathbf{\widehat{\theta}}_L\)</span> dado pelo lado direito da expressão <a href="capplanamo.html#eq:estpa19">(3.19)</a>. Para obter a variância do estimador linearizado, note que <span class="math inline">\(\mathbf{g(Y)}\)</span> é uma constante, e que</p>
<p><span class="math display">\[
\begin{array}{lll}
\mathbf{\Delta g(Y)} \left( \mathbf{\widehat{Y}}_{HT} - \mathbf{Y} \right) &amp; = &amp; \mathbf{\Delta g(Y)} \mathbf{\widehat{Y}}_{HT} - \mathbf{\Delta g(Y)} \mathbf{Y} \\  &amp; = &amp; \sum_{i \in s} \, d_i \, \mathbf{\Delta g(Y)} \mathbf{y}_{i} -
       \sum_{i \in U} \, \mathbf{\Delta g(Y)} \mathbf{y}_{i} \\
 &amp; = &amp; \sum_{i \in s} \, d_i \, \mathbf{z}_{i} - \sum_{i \in U} \, \mathbf{z}_{i} = \mathbf{\widehat{Z}}_{HT} - \mathbf{Z}
\end{array}
\]</span>
onde <span class="math inline">\(\mathbf{z}_{i} = \mathbf{\Delta g(Y)} \mathbf{y}_{i}\)</span>.</p>
<p>Logo, a variância aproximada por linearização do estimador <span class="math inline">\(\widehat{\theta}\)</span> pode ser obtida usando a expressão <a href="capplanamo.html#eq:estpa2">(3.2)</a>
<span class="math display">\[
 V_p \left( \widehat{\theta} \right) \doteq V_p \left( \mathbf{\widehat{Z}}_{HT} \right) 
\]</span></p>
<p>Este resultado segue porque na expressão do lado direito o único termo que tem variância de aleatorização é <span class="math inline">\(\mathbf{\widehat{Z}}_{HT}\)</span>.</p>
<p>Um estimador consistente de <span class="math inline">\(V_{p} \left( \mathbf{\widehat{\theta}}\right)\)</span> é dado por:</p>
<p><span class="math display" id="eq:estpa20">\[\begin{equation}
\widehat{V}_{p} \left( \mathbf{\widehat{\theta}} \right) = \widehat{V}_{p} \left( \mathbf{\widehat{Z}}_{HT} \right)  \,\,\,  \tag{3.20}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\widehat{V}_{p}\left( \mathbf{\widehat{Z}}_{HT}\right)\)</span> é dado em <a href="capplanamo.html#eq:estpa3">(3.3)</a>, onde substituímos o vetor de variáveis resposta original <span class="math inline">\(\mathbf{y}_i\)</span> pelo vetor de variáveis linearizadas <span class="math inline">\(\mathbf{z}_{i} = \mathbf{\Delta g(Y)} \mathbf{y}_{i}\)</span>.</p>
<p>Linearização de Taylor pode ser trabalhosa, porque para cada parâmetro/estimador de interesse são requeridas derivações e cálculos específicos. Felizmente, grande parte das situações de interesse prático estão hoje cobertas por pacotes estatísticos especializados na estimação de medidas descritivas e parâmetros de modelos, e suas respectivas variâncias de aleatorização empregando o método de linearização, de modo que essa desvantagem potencial tende a se diluir.</p>
<p>Linearização de Taylor pode não ser imediatamente possível, pois pode ocorrer que as quantidades de interesse não podem ser expressas como funções de totais ou médias populacionais (este é o caso de quantis de distribuições, por exemplo). Para estes casos é necessário recorrer a outras técnicas de estimação de variâncias, como discutido, por exemplo, em <span class="citation">Wolter (2007)</span>.</p>
</div>
<div id="equações-de-estimação" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Equações de estimação</h2>
<div style="text-align: justify">
<p>Até aqui, falamos da estimação de totais e de parâmetros que podem ser escritos como funções de totais. O caminho para obter resultados gerais referentes a muitos outros parâmetros de interesse é o que discutimos nesta seção.</p>
<p>Se um parâmetro populacional de interesse <span class="math inline">\(\theta_U\)</span> é uma solução única de um sistema de equações de estimação definidas como</p>
<p><span class="math display" id="eq:estpa21">\[\begin{equation}
\sum_{i \in U} \mathbf{u_i(\theta)} = \mathbf{0}  \,\,\, \tag{3.21}
\end{equation}\]</span></p>
<p>para uma função <span class="math inline">\(\mathbf{u(\bullet)}\)</span> conhecida, então é possível estimar o parâmetro <span class="math inline">\(\theta_U\)</span> usando o estimador <span class="math inline">\(\widehat \theta\)</span> obtido resolvendo as equações de estimação amostrais:</p>
<p><span class="math display" id="eq:estpa22">\[\begin{equation}
\sum_{i \in s} d_i \, \mathbf{u_i(\theta)} = \mathbf{0}  \,\,\, \tag{3.22}
\end{equation}\]</span></p>
<p>O estimador <span class="math inline">\(\widehat \theta\)</span> é consistente para <span class="math inline">\(\theta_U\)</span>, e adiante mostraremos como o método de Linearização de Taylor pode ser usado para estimar a sua variância. Antes, porém, vamos usar alguns exemplos para ilustrar casos particulares relevantes de como aplicar essa ideia.</p>

<div class="example">
<span id="exm:exe32" class="example"><strong>Exemplo 3.2  </strong></span>Estimação de médias populacionais
</div>
<p>Para ilustrar a aplicação da abordagem de equações de estimação, considere o caso em que a função <span class="math inline">\(\mathbf{u_i(\theta)} = y_i - \theta\)</span>. Nesse caso, as equações de estimação populacionais <a href="capplanamo.html#eq:estpa21">(3.21)</a> simplificam para:</p>
<p><span class="math display">\[
\sum_{i \in U} \mathbf{u_i(\theta)} = \sum_{i \in U} (y_i - \theta) = \mathbf{0}
\]</span>
Resolvendo esta equação, obtemos:</p>
<p><span class="math display">\[
\theta_U = \frac{1}{N} \sum_{i \in U} y_i = \overline{Y}
\]</span>
A solução das equações de estimação amostrais fornece:</p>
<p><span class="math display">\[
\widehat \theta = \frac{\sum_{i \in s} d_i y_i}{{\sum_{i \in s} d_i}} = \overline{y}_{Hàjek}
\]</span>
que é o conhecido estimador de Hàjek da média populacional.</p>

<div class="example">
<span id="exm:exe33" class="example"><strong>Exemplo 3.3  </strong></span>Estimação de razões populacionais
</div>
<p>Considere agora o caso em que a função <span class="math inline">\(\mathbf{u_i(\theta)} = y_i - \theta z_i\)</span>. Nesse caso, as equações de estimação populacionais <a href="capplanamo.html#eq:estpa21">(3.21)</a> simplificam para:</p>
<p><span class="math display">\[
\sum_{i \in U} \mathbf{u_i(\theta)} = \sum_{i \in U} (y_i - \theta z_i) = \mathbf{0}
\]</span>
Resolvendo esta equação, obtemos:</p>
<p><span class="math display">\[
\theta_U = \frac{\sum_{i \in U} y_i}{\sum_{i \in U} z_i} = \frac{Y}{Z} = R
\]</span>
A solução das equações de estimação amostrais correspondentes fornece:</p>
<p><span class="math display">\[
\widehat \theta = \frac{\sum_{i \in s} d_i y_i}{\sum_{i \in s} d_i z_i} = \frac{\widehat{Y}_{HT}}{\widehat{Z}_{HT}} = \widehat{R}
\]</span>
Os exemplos apresentados ilustram que a estimação de médias e razões populacionais são casos particulares simples da abordagem mais geral de <em>equações de estimação</em>. Essa abordagem também se mostrará útil quando lidamos com a estimação de parâmetros sob vários tipos de modelos paramétricos, que está apresentada nos capítulos seguintes deste livro. É também graças a ela que foi possível desenvolver software genérico para estimação a partir de amostras complexas, como é o caso do pacote <em>survey</em> do sistema R.</p>
<p>A estimação de variâncias nesse caso pode ser feita usando o método de Linearização de Taylor, empregando a estratégia de calcular variáveis linearizadas <span class="math inline">\(z\)</span> definidas como na Seção <a href="capplanamo.html#taylor">3.3</a>. Esta é a estratégia adotada no pacote <em>survey</em> do sistema R.</p>
</div>
<div id="método-do-conglomerado-primário" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Método do Conglomerado Primário</h2>
<div style="text-align: justify">
<p>A ideia central do Método do Conglomerado Primário (do inglês <em>Ultimate Cluster</em>) para estimação de variâncias para estimadores de totais e médias em planos amostrais de múltiplos estágios, proposto por <span class="citation">Hansen et al. (1953)</span>, é considerar apenas a variação entre informações disponíveis no nível das unidades primárias de amostragem - UPAs, isto é, dos <em>conglomerados primários</em>, e admitir que estes teriam sido selecionados com reposição da população de UPAs. Esta ideia é simples, porém bastante poderosa, porque permite acomodar uma enorme variedade de planos amostrais envolvendo estratificação, amostragem conglomerada e seleção com probabilidades desiguais (com ou sem reposição) tanto das UPAs como das demais unidades de amostragem.</p>
<p>Os requisitos fundamentais para permitir a aplicação deste método são que estejam disponíveis estimadores não viciados dos totais da variável de interesse para cada um dos conglomerados primários selecionados, e que pelo menos dois destes sejam selecionados em cada estrato (se a amostra for estratificada no primeiro estágio).</p>
<p>Embora o método tenha sido originalmente proposto para estimação de totais, pode ser aplicado também para estimar (por linearização) quantidades populacionais que possam ser representadas como funções de totais, conforme discutido na Seção <a href="capplanamo.html#taylor">3.3</a>. De fato, esse método fornece a base para ferramentas dos sistemas
estatísticos para cálculo de variâncias considerando o plano amostral, tais como o pacote <em>survey</em> do R, as funções <em>svy</em> do STATA, o módulo <em>Complex Samples</em> do SPSS, as procs <em>Survey</em> do SAS, entre outros.</p>
<p>Para descrever o método, considere um plano amostral em vários estágios, no qual <span class="math inline">\(n_{h}\)</span> unidades primárias de amostragem - UPAs foram selecionadas no estrato <span class="math inline">\(h\)</span>, com <span class="math inline">\(h=1, \ldots, H\)</span>. Denotemos por <span class="math inline">\(\pi_{hi}\)</span> a probabilidade de inclusão na amostra da UPA (conglomerado primário) <span class="math inline">\(i\)</span> do estrato <span class="math inline">\(h\)</span>, e por <span class="math inline">\(\widehat{Y}_{hi}\)</span> um estimador não viciado do total <span class="math inline">\(Y_{hi}\)</span> da variável de pesquisa <span class="math inline">\(y\)</span> na <span class="math inline">\(i\)</span>-ésima UPA do estrato <span class="math inline">\(h\)</span>. Então um estimador não viciado do total <span class="math inline">\(Y = \sum_{h=1}^{H} \sum_{i=1}^{N_{h}} Y_{hi}\)</span> da variável de pesquisa <span class="math inline">\(y\)</span> na população é dado por</p>
<p><span class="math display" id="eq:estpa23">\[\begin{equation}
\widehat{Y}_{CP} = \sum_{h=1}^{H} \sum_{i=1}^{n_{h}} \widehat{Y}_{hi} / \pi _{hi} \,\,\, \tag{3.23} 
\end{equation}\]</span></p>
<p>e um estimador não viciado da variância de aleatorização correspondente por</p>
<p><span class="math display" id="eq:estpa24">\[\begin{equation}
\widehat{V}_{p} \left( \widehat{Y}_{CP}\right) = \sum_{h=1}^{H}\frac{n_{h}}
{n_{h}-1} \sum_{i=1}^{n_{h}} \left( \frac{\widehat{Y}_{hi}}{\pi _{hi}} -
\frac{\widehat{Y}_{h}}{n_{h}} \right) ^{2}  \tag{3.24}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\widehat{Y}_{h} = \sum_{i=1}^{n_{h}} \widehat{Y}_{hi} / \pi _{hi}\)</span> para
<span class="math inline">\(h=1,\ldots ,H\)</span>. (Ver por exemplo, <span class="citation">Shah et al. (1993)</span>, p. 4).</p>
<p>Embora na prática a seleção das UPAs seja geralmente feita sem reposição, o estimador do Método do Conglomerado Primário - MCP aqui apresentado pode fornecer uma aproximação razoável da correspondente variância de aleatorização, especialmente nos casos em que as frações amostrais de UPAs são pequenas nos estratos. Isso ocorre porque planos amostrais sem reposição são em geral mais eficientes que planos com reposição de igual tamanho.</p>
<p>Tal aproximação é largamente utilizada pelos praticantes de amostragem para estimar variâncias de quantidades descritivas usuais tais como totais e médias (com a devida adaptação) devido à sua simplicidade, comparada com a complexidade muito maior envolvida com o emprego de estimadores de variância que tentam incorporar todas as etapas de planos amostrais conglomerados em vários estágios. Uma discussão sobre a qualidade dessa aproximação e alternativas pode ser encontrada em <span class="citation">Särndal et al. (1992)</span>, p. 153.</p>
</div>
<div id="métodos-de-replicação" class="section level2" number="3.6">
<h2><span class="header-section-number">3.6</span> Métodos de replicação</h2>
<div style="text-align: justify">
<p>A ideia de usar métodos indiretos ou de replicação para estimar variâncias em amostragem não é nova. <span class="citation">Mahalanobis (1939)</span>, <span class="citation">Mahalanobis (1944)</span> e <span class="citation">Deming (1956)</span> foram os precursores e muitos desenvolvimentos importantes se seguiram. Hoje em dia várias técnicas baseadas nessa ideia são rotineiramente empregadas por praticantes de amostragem, e
inclusive formam a base para pacotes especializados de estimação tais como WesVarPC (ver <span class="citation">Westat (1996)</span>).</p>
<p>A ideia básica original foi construir a amostra de tamanho <span class="math inline">\(n\)</span> como a união de <span class="math inline">\(G\)</span> amostras de tamanho <span class="math inline">\(n/G\)</span> cada uma, selecionadas de forma independente e usando o mesmo plano amostral, onde <span class="math inline">\(G\)</span> é o número de <em>réplicas</em>. Nesse caso, se <span class="math inline">\(\theta\)</span> é o parâmetro-alvo, e <span class="math inline">\(\widehat{\theta}_{g}\)</span> é um estimador não viciado de <span class="math inline">\(\theta\)</span> baseado na <span class="math inline">\(g\)</span>-ésima réplica <span class="math inline">\((g=1,\ldots ,G)\)</span>, segue-se que</p>
<p><span class="math display">\[
\widehat{\theta }_{G}=\frac{1}{G}\sum_{g=1}^{G}\widehat{\theta }_{g} 
\]</span></p>
<p>é também um estimador não viciado de <span class="math inline">\(\theta\)</span> e</p>
<p><span class="math display" id="eq:estpa25">\[\begin{equation}
\widehat{V}_{G} \left( \widehat{\theta }_{G}\right) = \frac{1}{G \left(
G-1 \right)} \sum_{g=1}^{G} \left( \widehat{\theta }_{g} - \widehat{\theta}_{G} \right)^{2}  \,\, \tag{3.25}
\end{equation}\]</span></p>
<p>é um estimador não viciado (de replicação) da variância do estimador <span class="math inline">\(\widehat{\theta}_{G}\)</span>.</p>
<p>Note que desde que as réplicas sejam construídas de forma independente conforme indicado, os estimadores <span class="math inline">\(\widehat{\theta }_{G}\)</span> e <span class="math inline">\(\widehat{V}_{G}\left( \widehat{\theta }_{G}\right)\)</span> são não viciados qualquer que seja o plano amostral empregado para selecionar a amostra de cada réplica, o que faz desta uma técnica
flexível e genérica. Além disso, a abordagem de replicação é bastante geral, pois os estimadores aos quais se aplica não precisam ser necessariamente expressos como funções de totais, como ocorre com a técnica de Linearização de Taylor discutida na Seção <a href="capplanamo.html#taylor">3.3</a>.</p>
<p>Apesar destas vantagens, a aplicação prática desta técnica de forma exata é restrita porque, em geral, é menos eficiente, inconveniente e mais caro selecionar <span class="math inline">\(G\)</span> amostras (réplicas) independentes com o mesmo esquema, se comparado à seleção de uma única amostra de tamanho <span class="math inline">\(n\)</span> diretamente. Além disto, se o número de
réplicas <span class="math inline">\(G\)</span> for pequeno, o estimador de variância pode ser instável.</p>
<p>Mesmo quando a amostra não foi selecionada exatamente dessa forma, a construção de réplicas a posteriori para fins de estimação de variâncias em situações complexas é também uma ideia simples de aplicar, poderosa e flexível, por acomodar uma ampla gama de planos amostrais e situações de estimação de interesse. Quando as réplicas são construídas após a pesquisa (a posteriori), mediante repartição (por sorteio) da amostra pesquisada em <span class="math inline">\(G\)</span> grupos mutuamente exclusivos de igual tamanho, estas são chamadas de <em>réplicas dependentes</em> ou <em>grupos aleatórios</em> (do inglês <em>random groups</em>). As expressões fornecidas para o estimador de replicação e sua
variância são também empregadas nesse caso como uma aproximação, mas não possuem as mesmas propriedades do caso de réplicas independentes.</p>
<p>Uma pesquisa importante e de grande porte em que esta ideia é aplicada é a pesquisa de preços para formar o índice de Preços ao Consumidor (do inglês <em>Consumer Price Index - CPI</em>) do <em><span class="citation">US Bureau of Labour Statistics (2020)</span></em>, p. 46, que utiliza duas ou mais réplicas para formar a amostra de itens cujos preços são pesquisados.</p>
<p>É importante observar que a repartição da amostra em grupos aleatórios a posteriori precisa considerar o plano amostral empregado e pode não ser possível em algumas situações. Idealmente, tal repartição deveria ser feita respeitando estratos e alocando UPAs inteiras (isto é, com todas as respectivas unidades subordinadas). <span class="citation">Wolter (1985)</span>, p. 31, discute algumas regras sobre como fazer para respeitar o plano amostral ao fazer a repartição da amostra a posteriori, porém recomendamos que o interessado no uso dessa técnica exerça cautela.</p>
<p>Além da modificação da interpretação das réplicas no caso de serem formadas a posteriori, é comum também nesse caso empregar um estimador para o parâmetro <span class="math inline">\(\theta\)</span> baseado na amostra completa (denotado <span class="math inline">\(\widehat{\theta}\)</span>), e um estimador de variância mais conservador que o estimador <span class="math inline">\(\widehat{V}_{G}\left( \widehat{\theta }_{G}\right)\)</span> anteriormente apresentado, dado por</p>
<p><span class="math display" id="eq:estpa26">\[\begin{equation}
\widehat{V}_{G}\left( \widehat{\theta }\right) =\frac{1}{G\left( G-1\right) 
}\sum_{g=1}^{G}\left( \widehat{\theta }_{g}-\widehat{\theta }\right) ^{2} \,\,
\tag{3.26}
\end{equation}\]</span></p>
<p>Um exemplo de aplicação desta técnica pode ser encontrado na forma recomendada para estimação de variâncias a partir das Amostras de Uso Público do Censo Demográfico Brasileiro de 80 (ver <span class="citation">IBGE (1985)</span>).</p>
<p>Nesta seção descreveremos duas outras dessas técnicas baseadas em replicações. A primeira é o método de <em>jackknife</em>. Este método foi originalmente proposto por <span class="citation">Quenoille (1949)</span> e <span class="citation">Quenoille (1956)</span> como uma técnica para redução de vício de estimadores, num contexto da Estatística Clássica. A ideia central consiste em repartir a amostra (a posteriori, como no caso do método dos grupos aleatórios) em <span class="math inline">\(G\)</span> grupos mutuamente exclusivos de igual tamanho <span class="math inline">\(n/G\)</span>. Em seguida, para cada grupo formado calcular os chamados pseudo estimadores dados por</p>
<p><span class="math display">\[
\widehat{\theta }_{\left( g\right) }=G\widehat{\theta }-\left( G-1\right) 
\widehat{\theta }_{g} 
\]</span></p>
<p>onde <span class="math inline">\(\widehat{\theta }_{g}\)</span> é um estimador de <span class="math inline">\(\theta\)</span> obtido da amostra após eliminar os elementos do grupo <span class="math inline">\(g\)</span>, empregando a mesma forma funcional adotada no cálculo do estimador <span class="math inline">\(\widehat{\theta}\)</span> que considera a amostra inteira.</p>
<p>A estimação da variância por esse método pode então ser feita de duas maneiras alternativas, usando um dos estimadores dados por</p>
<p><span class="math display" id="eq:estpa27">\[\begin{equation}
\widehat{V}_{J1}\left( \widehat{\theta }\right) =\frac{1}{G\left( G-1\right) 
}\sum_{g=1}^{G}\left( \widehat{\theta }_{\left( g\right) }-\widehat{\theta }
_{J}\right) ^{2}  \tag{3.27}
\end{equation}\]</span>
ou</p>
<p><span class="math display" id="eq:estpa28">\[\begin{equation}
\widehat{V}_{J2}\left( \widehat{\theta }\right) =\frac{1}{G\left( G-1\right) 
}\sum_{g=1}^{G}\left( \widehat{\theta }_{\left( g\right) }-\widehat{\theta }
\right) ^{2} \,\,\, \tag{3.28}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\widehat{\theta }_{J} = \frac{1}{G} \sum_{g=1}^{G} \widehat{\theta }_{\left( g\right)}\)</span> é um estimador pontual <em>jackknife</em> para <span class="math inline">\(\theta\)</span>, alternativo ao estimador da amostra inteira <span class="math inline">\(\hat{\theta}\)</span>.</p>
<p><strong>Observaçao 3.1:</strong> A descrição do método <em>jackknife</em> aqui apresentada não cobre o caso de planos amostrais estratificados, que é mais complexo. Para detalhes sobre este caso, consulte <span class="citation">Wolter (1985)</span>, pág. 174.</p>
<p><strong>Observaçao 3.2:</strong> O estimador <span class="math inline">\(\widehat{V}_{J2}\left( \widehat{\theta }\right)\)</span> é mais conservador que o estimador <span class="math inline">\(\widehat{V}_{J1}\left( \widehat{\theta }\right)\)</span>.</p>
<p><strong>Observaçao 3.3:</strong> É comum aplicar a técnica fazendo o número de grupos igual ao tamanho da amostra, isto é, tomando <span class="math inline">\(G=n\)</span> e portanto eliminando uma observação da amostra de cada vez ao calcular os pseudo valores. Essa regra deve ser aplicada considerando o número de UPAs quando o plano amostral é em múltiplos estágios, pois as UPAs devem sempre ser eliminadas com todas as unidades subordinadas.</p>
<p>Os estimadores de variância do método <em>jackknife</em> fornecem resultadoS idênticos aos dos estimadores usuais de variância quando aplicados para o caso de estimadores lineares nas observações amostrais. Além disso, suas propriedades são razoáveis para vários outros casos de estimadores não lineares de interesse (ver, por exemplo, <span class="citation">Cochran (1977)</span>, p. 321 e <span class="citation">Wolter (1985)</span>, p. 306). A situação merece maiores cuidados para o caso de quantis ou estatísticas de ordem, tais como a mediana e o máximo, pois neste caso essa técnica não funciona bem <span class="citation">Wolter (1985)</span>, p. 163.</p>
<p>O pacote WesVarPC - <span class="citation">Westat (1996)</span> - baseia suas estimativas de variância principalmente no método <em>jackknife</em>, embora também possua uma opção para usar outro método conhecido como de replicações de meias amostras balanceadas (do inglês <em>balanced half-sample replication</em>).</p>
<p>O outro método de replicação que vamos considerar é uma variante do método <em>bootstrap</em> proposta por <span class="citation">Rao et al. (1992)</span>. O método consiste dos seguintes passos:</p>
<ol style="list-style-type: decimal">
<li><p>Selecione amostras aleatórias simples com reposição de <span class="math inline">\(m_h\)</span> das <span class="math inline">\(n_h\)</span> UPAs de cada estrato <span class="math inline">\(h=1, \dots, H\)</span>.</p></li>
<li><p>Calcule as contagens <span class="math inline">\(m_{hi}^*\)</span> de vezes que cada UPA <span class="math inline">\(i\)</span> aparece na amostra selecionada no estrato <span class="math inline">\(h\)</span>; note que <span class="math inline">\(\sum_i m_{hi}^* = m_h\)</span> para todo estrato <span class="math inline">\(h\)</span>;</p></li>
<li><p>Defina pesos <em>bootstrap</em> para as unidades da amostra selecionada em (1) usando:</p></li>
</ol>
<p><span class="math display" id="eq:estpa29">\[\begin{equation}
 w_{hik}^* = \left[ 1 - \left( \frac{m_h} {n_h - 1} \right)^{1/2} +  \left( \frac{m_h} {n_h - 1} \right)^{1/2} \times \frac{n_h} {m_h} \times m_{hi}^* \right] \times w_{hik}  \,\,\, \tag{3.29}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(w_{hik}\)</span> é o peso da unidade <span class="math inline">\(k\)</span> da UPA <span class="math inline">\(i\)</span> do estrato <span class="math inline">\(h\)</span>. Note que quando uma UPA <span class="math inline">\(i\)</span> não é selecionada, sua contagem <span class="math inline">\(m_{hi}^*\)</span> é igual a zero, e o terceiro termo dentro do colchete é nulo.</p>
<ol start="4" style="list-style-type: decimal">
<li><p>Calcule uma estimativa <span class="math inline">\(\widehat \theta _b\)</span> para o parâmetro de interesse usando os pesos <em>bootstrap</em> <span class="math inline">\(w_{hik}^*\)</span> em lugar dos pesos originais <span class="math inline">\(w_{hik}\)</span>.</p></li>
<li><p>Repita os passos 1) a 4) um número <span class="math inline">\(B\)</span> grande de vezes.</p></li>
<li><p>Estime a variância do estimador <span class="math inline">\(\widehat \theta\)</span> com:</p></li>
</ol>
<p><span class="math display" id="eq:estpa30">\[\begin{equation}
\widehat{V}_{B}\left( \widehat{\theta }\right) = \frac{1}{B} \sum_{b=1}^{B} \left( \widehat \theta _b - \widehat{\theta}
\right) ^{2} \,\,\, \tag{3.30}
\end{equation}\]</span></p>
<p>A Pesquisa Nacional por Amostra de Domicílios Contínua - PNAD Contínua do IBGE passou a usar este método <em>bootstrap</em> para estimação da precisão dos indicadores que divulga a partir do terceiro trimestre de 2021, ver <span class="citation">IBGE (2021)</span>.</p>
<p>Embora computacionalmente mais custoso que o método da Linearização de Taylor, o método <em>bootstrap</em> aqui descrito tem como vantagem a aplicação em casos onde o estimador não é função suave de totais populacionais, tais como separatrizes (quantis), algumas medidas de desigualdade e pobreza etc. Além disso, o método pode ser aplicado com qualquer software que permita implementar o algoritmo descrito, e não requer pacotes especializados. Vale mencionar, entretanto, que este método está disponível no pacote <em>survey</em> do sistema R. Sua utilização é ilustrada em capítulos posteriores.</p>
<p>XXX Parei aqui</p>
</div>
<div id="laboratório-de-r" class="section level2" number="3.7">
<h2><span class="header-section-number">3.7</span> Laboratório de R</h2>
<div style="text-align: justify">
<p>Vamos utilizar dados da Pesquisa de Padrão de Vida (PPV) do IBGE para ilustrar alguns métodos de estimação de variâncias. Vamos considerar a estimação da proporção de analfabetos na faixa etária acima de 14 anos. Os dados da pesquisa encontram-se no data frame . A variável <em>analf2</em> é indicadora da condição
de analfabetismo na faixa etária acima de 14 anos e a variável <em>faixa2</em> é indicadora da faixa etária acima de 14 anos. Queremos estimar a proporção de analfabetos na faixa etária acima de 14 anos na região Sudeste. Antes apresentamos o método de estimação de variância por linearização de Taylor</p>
<p>Vamos criar duas variáveis:</p>
<ul>
<li>analf - variável indicadora da condição de analfabetismo: <em>v04a01</em> ou
<code>v04a02</code> igual a 2;</li>
<li>faixa - variável indicadora de faixa etária entre 7 e 14 anos.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="capplanamo.html#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(survey)</span>
<span id="cb1-2"><a href="capplanamo.html#cb1-2" aria-hidden="true" tabindex="-1"></a>ppv_dat <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">&quot;./data/ppv.rds&quot;</span>) <span class="co"># carrega dados</span></span>
<span id="cb1-3"><a href="capplanamo.html#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cria objeto de desenho</span></span>
<span id="cb1-4"><a href="capplanamo.html#cb1-4" aria-hidden="true" tabindex="-1"></a>ppv_plan<span class="ot">&lt;-</span><span class="fu">svydesign</span>(<span class="at">ids =</span> <span class="sc">~</span>nsetor, <span class="at">strata =</span> <span class="sc">~</span>estratof,</span>
<span id="cb1-5"><a href="capplanamo.html#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">data =</span> ppv_dat, <span class="at">nest =</span> <span class="cn">TRUE</span>, <span class="at">weights =</span> <span class="sc">~</span>pesof)</span>
<span id="cb1-6"><a href="capplanamo.html#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># atualiza objeto de desenho com novas variáveis</span></span>
<span id="cb1-7"><a href="capplanamo.html#cb1-7" aria-hidden="true" tabindex="-1"></a>ppv_plan<span class="ot">&lt;-</span><span class="fu">update</span>(ppv_plan,</span>
<span id="cb1-8"><a href="capplanamo.html#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">analf=</span>(v04a01 <span class="sc">==</span> <span class="dv">2</span> <span class="sc">|</span> v04a02 <span class="sc">==</span> <span class="dv">2</span>)<span class="sc">*</span><span class="dv">1</span>,</span>
<span id="cb1-9"><a href="capplanamo.html#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">faixa=</span>(v02a08 <span class="sc">&gt;=</span> <span class="dv">7</span> <span class="sc">&amp;</span> v02a08 <span class="sc">&lt;=</span> <span class="dv">14</span>) <span class="sc">*</span><span class="dv">1</span>,</span>
<span id="cb1-10"><a href="capplanamo.html#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">analf.faixa=</span> (analf<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;</span> faixa<span class="sc">==</span><span class="dv">1</span>)<span class="sc">*</span><span class="dv">1</span></span>
<span id="cb1-11"><a href="capplanamo.html#cb1-11" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Como estamos interessados em estimativas relativas à Região Sudeste, vamos restringir o desenho a esse domínio:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="capplanamo.html#cb2-1" aria-hidden="true" tabindex="-1"></a>ppv_se_plan <span class="ot">&lt;-</span> <span class="fu">subset</span>(ppv_plan, regiao <span class="sc">==</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Vamos estimar os totais das variáveis <em>analf.faixa</em> e <em>faixa</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="capplanamo.html#cb3-1" aria-hidden="true" tabindex="-1"></a>analf_faixa_tot_est<span class="ot">&lt;-</span><span class="fu">svytotal</span>(<span class="sc">~</span>analf.faixa<span class="sc">+</span>faixa ,ppv_se_plan )</span>
<span id="cb3-2"><a href="capplanamo.html#cb3-2" aria-hidden="true" tabindex="-1"></a>Vcov.Y1.Y2<span class="ot">&lt;-</span><span class="fu">vcov</span>(analf_faixa_tot_est) </span></code></pre></div>
<p>Substituindo os valores na expressão <a href="capplanamo.html#eq:estpa21">(3.21)</a>, obtemos a estimativa da variância da razão de totais das variáveis <em>analf.faixa</em> e <em>faixa</em>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="capplanamo.html#cb4-1" aria-hidden="true" tabindex="-1"></a>y1hat<span class="ot">&lt;-</span><span class="fu">coef</span>(analf_faixa_tot_est)[<span class="dv">1</span>]</span>
<span id="cb4-2"><a href="capplanamo.html#cb4-2" aria-hidden="true" tabindex="-1"></a>y2hat<span class="ot">&lt;-</span><span class="fu">coef</span>(analf_faixa_tot_est)[<span class="dv">2</span>]</span>
<span id="cb4-3"><a href="capplanamo.html#cb4-3" aria-hidden="true" tabindex="-1"></a>Var.raz<span class="ot">&lt;-</span>(<span class="dv">1</span><span class="sc">/</span>y2hat)<span class="sc">*</span>(<span class="dv">1</span><span class="sc">/</span>y2hat)<span class="sc">*</span>Vcov.Y1.Y2[<span class="dv">1</span>,<span class="dv">1</span>]<span class="sc">+</span><span class="dv">2</span><span class="sc">*</span>(<span class="dv">1</span><span class="sc">/</span>y2hat)<span class="sc">*</span>(<span class="sc">-</span>y1hat<span class="sc">/</span>y2hat<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span>Vcov.Y1.Y2[<span class="dv">1</span>,<span class="dv">2</span>]<span class="sc">+</span></span>
<span id="cb4-4"><a href="capplanamo.html#cb4-4" aria-hidden="true" tabindex="-1"></a>(<span class="sc">-</span>y1hat<span class="sc">/</span>y2hat<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span>(<span class="sc">-</span>y1hat<span class="sc">/</span>y2hat<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span>Vcov.Y1.Y2[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb4-5"><a href="capplanamo.html#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># estimativa do desvio-padrão</span></span>
<span id="cb4-6"><a href="capplanamo.html#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(Var.raz)</span></code></pre></div>
<pre><code>##  faixa 
## 0,0118</code></pre>
<p>Podemos calcular diretamente o desvio-padrão:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="capplanamo.html#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">svyratio</span>(<span class="sc">~</span>analf.faixa, <span class="sc">~</span>faixa, ppv_se_plan)</span></code></pre></div>
<pre><code>## Ratio estimator: svyratio.survey.design2(~analf.faixa, ~faixa, ppv_se_plan)
## Ratios=
##             faixa
## analf.faixa 0,119
## SEs=
##              faixa
## analf.faixa 0,0118</code></pre>
<p>A estimativa do desvio-padrão obtida por meio da função <em>svyratio</em> coincide com a obtida diretamente pelo método
de linearização, e é igual a <em>r round(sqrt(Var.raz),digits=5)</em>. O método default para estimar variâncias
usado pela library <em>survey</em> <span class="citation">(Lumley, 2021)</span> do R é o de linearização de Taylor.</p>
<p>A library <em>survey</em> dispõe de métodos alternativos para a estimação de variância. Vamos utilizar os métodos de replicação
de <em>Jackknife</em> e de <em>Bootstrap</em> para estimar esta variância de razão. Inicialmente, vamos converter o objeto de desenho <em>ppv1_se_plan</em> em um objeto de desenho de replicação de tipo <em>Jackknife</em>, contendo as réplicas de pesos que fornecem correspondentes réplicas de estimativas.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="capplanamo.html#cb8-1" aria-hidden="true" tabindex="-1"></a>ppv_se_plan_jkn<span class="ot">&lt;-</span><span class="fu">as.svrepdesign</span>(ppv_se_plan,<span class="at">type=</span><span class="st">&quot;JKn&quot;</span>)</span>
<span id="cb8-2"><a href="capplanamo.html#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">svyratio</span>(<span class="sc">~</span>analf.faixa, <span class="sc">~</span>faixa, ppv_se_plan_jkn)</span></code></pre></div>
<pre><code>## Ratio estimator: svyratio.svyrep.design(~analf.faixa, ~faixa, ppv_se_plan_jkn)
## Ratios=
##             faixa
## analf.faixa 0,119
## SEs=
##        [,1]
## [1,] 0,0118</code></pre>
<p>Para o tipo <em>Bootstrap</em>, temos:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="capplanamo.html#cb10-1" aria-hidden="true" tabindex="-1"></a>ppv_se_plan_boot<span class="ot">&lt;-</span><span class="fu">as.svrepdesign</span>(ppv_se_plan,<span class="at">type=</span><span class="st">&quot;bootstrap&quot;</span>)</span>
<span id="cb10-2"><a href="capplanamo.html#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">svyratio</span>(<span class="sc">~</span>analf.faixa, <span class="sc">~</span>faixa, ppv_se_plan_boot)</span></code></pre></div>
<pre><code>## Ratio estimator: svyratio.svyrep.design(~analf.faixa, ~faixa, ppv_se_plan_boot)
## Ratios=
##             faixa
## analf.faixa 0,119
## SEs=
##        [,1]
## [1,] 0,0104</code></pre>
<p>Vamos apresentar mais detalhes sobre a obtenção dos estimadores de <em>Jackknife</em> e <em>Bootstrap</em> na library <em>survey</em> <span class="citation">(Lumley, 2021)</span>.
A classe do objeto <em>ppv_se_plan_jkn</em> é <em>svyrep.design</em> e ele contém as seguintes componentes:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="capplanamo.html#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(ppv_se_plan_jkn)</span></code></pre></div>
<pre><code>## [1] &quot;svyrep.design&quot;</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="capplanamo.html#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(ppv_se_plan_jkn)</span></code></pre></div>
<pre><code>##  [1] &quot;repweights&quot;       &quot;pweights&quot;         &quot;type&quot;             &quot;rho&quot;             
##  [5] &quot;scale&quot;            &quot;rscales&quot;          &quot;call&quot;             &quot;combined.weights&quot;
##  [9] &quot;selfrep&quot;          &quot;mse&quot;              &quot;variables&quot;        &quot;degf&quot;</code></pre>
<p>A componente <em>repweights</em> é uma lista com duas componentes: <em>weights</em> e <em>index</em>. A componente
<em>weights</em> é uma matriz de dimensão <span class="math inline">\(276 \times 276\)</span>, onde <span class="math inline">\(276\)</span> é o número de conglomerados primários do plano
amostral da PPV na região Sudeste. A partir desta matriz, podemos obter <span class="math inline">\(276\)</span> réplicas de pesos de desenho de Jackknife.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="capplanamo.html#cb16-1" aria-hidden="true" tabindex="-1"></a>ppv_se_dat<span class="ot">&lt;-</span>ppv_se_plan_jkn<span class="sc">$</span>variables</span>
<span id="cb16-2"><a href="capplanamo.html#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(ppv_se_dat)</span></code></pre></div>
<pre><code>## [1] 8903</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="capplanamo.html#cb18-1" aria-hidden="true" tabindex="-1"></a>ncong<span class="ot">&lt;-</span><span class="fu">sum</span>(<span class="fu">with</span>(ppv_se_dat,<span class="fu">tapply</span>( nsetor,estratof, <span class="cf">function</span>(t) <span class="fu">length</span>(<span class="fu">unique</span>(t)))))</span>
<span id="cb18-2"><a href="capplanamo.html#cb18-2" aria-hidden="true" tabindex="-1"></a>ncong</span></code></pre></div>
<pre><code>## [1] 276</code></pre>
<p>O argumento <em>compress</em> da função <em>as.svrepdesign</em> permite especificar se, na saída da função, a matriz
<code>weights</code> é na forma comprimida ou não. Na aplicação feita foi usado o valor default que é a forma comprimida.
A forma não comprimida da matriz <em>weights</em> tem <em>r nrow(ppv_se_dat)</em> linhas e <em>r ncong</em> colunas. A forma comprimida
permite economizar memória, e pode ser facilmente convertida para a forma não comprimida, utilizando-se a componente<code>index</code>.</p>
<p>No método <em>jackknife</em>, cada um dos conglomerados primários é removido, e a réplica correspondente dos pesos é o produto
do peso amostral original por um fator apropriado, definido da forma a seguir. Suponhamos que foi removido um conglomerado
no estrato <span class="math inline">\(h\)</span>, então os pesos do plano amostral serão multiplicados por:</p>
<ul>
<li><span class="math inline">\(0\)</span> para as unidades no conglomerado removido;</li>
<li><span class="math inline">\(m_h/(m_h-1)\)</span> para unidades pertencentes a outros conglomerados do estrato <span class="math inline">\(h\)</span>;</li>
<li><span class="math inline">\(1\)</span> para unidades em estratos <span class="math inline">\(h&#39;\neq h\)</span>.</li>
</ul>
<p>Podemos obter a matriz de fatores de correção do peso amostral na forma não comprimida da seguinte maneira:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="capplanamo.html#cb20-1" aria-hidden="true" tabindex="-1"></a>fact_peso_comp_mat<span class="ot">&lt;-</span>ppv_se_plan_jkn<span class="sc">$</span>repweights[[<span class="dv">1</span>]]</span>
<span id="cb20-2"><a href="capplanamo.html#cb20-2" aria-hidden="true" tabindex="-1"></a>ind_cong <span class="ot">&lt;-</span>ppv_se_plan_jkn<span class="sc">$</span>repweights[[<span class="dv">2</span>]]</span>
<span id="cb20-3"><a href="capplanamo.html#cb20-3" aria-hidden="true" tabindex="-1"></a>fat_pesos_mat<span class="ot">&lt;-</span> fact_peso_comp_mat[ind_cong,]</span>
<span id="cb20-4"><a href="capplanamo.html#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(fat_pesos_mat)</span></code></pre></div>
<pre><code>##  num [1:8903, 1:276] 0 0 1,06 1,06 1,06 ...</code></pre>
<p>Podemos obter matriz de réplicas de pesos multiplicando cada coluna dessa matriz pelos pesos do plano amostra:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="capplanamo.html#cb22-1" aria-hidden="true" tabindex="-1"></a>rep_pesos_mat<span class="ot">&lt;-</span><span class="fu">weights</span>(ppv_se_plan)<span class="sc">*</span>fat_pesos_mat</span></code></pre></div>
<p>Utilizando esta matriz de réplicas de pesos, podemos obter réplicas correspondentes de estimativas da razão.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="capplanamo.html#cb23-1" aria-hidden="true" tabindex="-1"></a>rep_est_raz<span class="ot">&lt;-</span><span class="fu">numeric</span>(<span class="fu">ncol</span>(rep_pesos_mat))</span>
<span id="cb23-2"><a href="capplanamo.html#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(rep_pesos_mat)){</span>
<span id="cb23-3"><a href="capplanamo.html#cb23-3" aria-hidden="true" tabindex="-1"></a>rep_est_raz[i]<span class="ot">&lt;-</span><span class="fu">sum</span>(rep_pesos_mat[,i]<span class="sc">*</span>ppv_se_dat<span class="sc">$</span>analf.faixa)<span class="sc">/</span><span class="fu">sum</span>(rep_pesos_mat[,i]<span class="sc">*</span>ppv_se_dat<span class="sc">$</span>faixa)</span>
<span id="cb23-4"><a href="capplanamo.html#cb23-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A partir destas réplicas de estimativas da razão, finalmente estimamos a variância:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="capplanamo.html#cb24-1" aria-hidden="true" tabindex="-1"></a>mean_raz<span class="ot">&lt;-</span><span class="fu">mean</span>( rep_est_raz[ppv_se_plan_jkn<span class="sc">$</span>rscales<span class="sc">&gt;</span><span class="dv">0</span>])</span>
<span id="cb24-2"><a href="capplanamo.html#cb24-2" aria-hidden="true" tabindex="-1"></a>var_jack_raz<span class="ot">&lt;-</span> <span class="fu">sum</span>((rep_est_raz<span class="sc">-</span>mean_raz)<span class="sc">^</span><span class="dv">2</span><span class="sc">*</span>ppv_se_plan_jkn<span class="sc">$</span>rscales)<span class="sc">*</span>ppv_se_plan_jkn<span class="sc">$</span>scale</span>
<span id="cb24-3"><a href="capplanamo.html#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">sqrt</span>(var_jack_raz),<span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 0,0118</code></pre>
<p>A library <em>survey</em> <span class="citation">(Lumley, 2021)</span> fornece uma função para estimar a variância de uma função de totais a partir das réplicas de pesos:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="capplanamo.html#cb26-1" aria-hidden="true" tabindex="-1"></a>var_raz_rep<span class="ot">&lt;-</span><span class="fu">withReplicates</span>(ppv_se_plan_jkn, <span class="cf">function</span>(w,ppv_se_dat) <span class="fu">sum</span>(w<span class="sc">*</span>ppv_se_dat<span class="sc">$</span>analf.faixa)<span class="sc">/</span><span class="fu">sum</span>(w<span class="sc">*</span>ppv_se_dat<span class="sc">$</span>faixa))</span>
<span id="cb26-2"><a href="capplanamo.html#cb26-2" aria-hidden="true" tabindex="-1"></a>var_raz_rep </span></code></pre></div>
<pre><code>##      theta   SE
## [1,] 0,119 0,01</code></pre>
<p>Resultado que coincide com a estimativa obtida pela aplicação da função <em>svyratio</em>.</p>
<p>A vantagem de utilizar métodos de replicação é a facilidade com que estimamos a variância de qualquer
característica da população, cujo estimador pontual é conhecido. Por exemplo, se quisermos estimar a variância da razão das taxas de analfabetos nas faixas etárias de 0 a 14 anos e acima de 14 anos podemos usar as mesmas réplicas de pesos:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="capplanamo.html#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">withReplicates</span> (ppv_se_plan_jkn,<span class="cf">function</span>(w,ppv_se_dat) <span class="fu">with</span>(ppv_se_dat,</span>
<span id="cb28-2"><a href="capplanamo.html#cb28-2" aria-hidden="true" tabindex="-1"></a>(<span class="fu">sum</span>(w<span class="sc">*</span>(analf<span class="sc">==</span><span class="dv">1</span><span class="sc">&amp;</span>faixa<span class="sc">==</span><span class="dv">1</span>))<span class="sc">/</span><span class="fu">sum</span>(w<span class="sc">*</span>(faixa<span class="sc">==</span><span class="dv">1</span>)))<span class="sc">/</span>(<span class="fu">sum</span>(w<span class="sc">*</span>(analf<span class="sc">==</span><span class="dv">1</span><span class="sc">&amp;</span>faixa<span class="sc">==</span><span class="dv">0</span>))<span class="sc">/</span><span class="fu">sum</span>(w<span class="sc">*</span>(faixa<span class="sc">==</span><span class="dv">0</span>)))</span>
<span id="cb28-3"><a href="capplanamo.html#cb28-3" aria-hidden="true" tabindex="-1"></a>))  </span></code></pre></div>
<pre><code>##      theta   SE
## [1,] 0,504 0,05</code></pre>
<p>O erro padrão da razão entre razões estimada no exemplo anterior pode ser estimado por linearização de Taylor, usando-se a função <em>svycontrast()</em> da library survey:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="capplanamo.html#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># cria variáveis dummies: </span></span>
<span id="cb30-2"><a href="capplanamo.html#cb30-2" aria-hidden="true" tabindex="-1"></a>ppv_se_plan <span class="ot">&lt;-</span> <span class="fu">update</span>(ppv_se_plan,</span>
<span id="cb30-3"><a href="capplanamo.html#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="at">num1 =</span> <span class="fu">as.numeric</span>(analf<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;</span> faixa<span class="sc">==</span><span class="dv">1</span>),</span>
<span id="cb30-4"><a href="capplanamo.html#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="at">num2 =</span> <span class="fu">as.numeric</span>(analf<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;</span> faixa<span class="sc">==</span><span class="dv">0</span>),</span>
<span id="cb30-5"><a href="capplanamo.html#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="at">den1 =</span> <span class="fu">as.numeric</span> (faixa <span class="sc">==</span> <span class="dv">1</span>),</span>
<span id="cb30-6"><a href="capplanamo.html#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="at">den2 =</span> <span class="fu">as.numeric</span>(faixa <span class="sc">==</span> <span class="dv">0</span>)</span>
<span id="cb30-7"><a href="capplanamo.html#cb30-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb30-8"><a href="capplanamo.html#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co"># estima totais e matriz de covariância de estimativas de totais</span></span>
<span id="cb30-9"><a href="capplanamo.html#cb30-9" aria-hidden="true" tabindex="-1"></a>comp.tot <span class="ot">&lt;-</span> <span class="fu">svytotal</span>(<span class="sc">~</span>num1<span class="sc">+</span>num2<span class="sc">+</span>den1<span class="sc">+</span>den2, ppv_se_plan)  </span>
<span id="cb30-10"><a href="capplanamo.html#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="capplanamo.html#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co"># estima razão de razões:  </span></span>
<span id="cb30-12"><a href="capplanamo.html#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="fu">svycontrast</span>(comp.tot, <span class="fu">quote</span>((num1<span class="sc">/</span>den1)<span class="sc">/</span>(num2<span class="sc">/</span>den2)))  </span></code></pre></div>
<pre><code>##          nlcon   SE
## contrast 0,504 0,05</code></pre>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="refinf.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="epa.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-adacor.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
